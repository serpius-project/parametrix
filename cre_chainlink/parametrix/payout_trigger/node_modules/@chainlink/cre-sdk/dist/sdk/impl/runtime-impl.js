import { create } from '@bufbuild/protobuf';
import { anyPack, anyUnpack } from '@bufbuild/protobuf/wkt';
import { AwaitCapabilitiesRequestSchema, AwaitSecretsRequestSchema, CapabilityRequestSchema, GetSecretsRequestSchema, Mode, SecretRequestSchema, SimpleConsensusInputsSchema, } from '../../generated/sdk/v1alpha/sdk_pb';
import { ConsensusCapability } from '../../generated-sdk/capabilities/internal/consensus/v1alpha/consensus_sdk_gen';
import { Value, } from '../utils';
import { CapabilityError } from '../utils/capabilities/capability-error';
import { DonModeError, NodeModeError, SecretsError } from '../errors';
/**
 * Base implementation shared by DON and Node runtimes.
 *
 * Call ID Management:
 * - DON mode: IDs increment (1, 2, 3...)
 * - Node mode: IDs decrement (-1, -2, -3...)
 * This prevents collisions when both modes are active.
 */
export class BaseRuntimeImpl {
    config;
    nextCallId;
    helpers;
    maxResponseSize;
    mode;
    /**
     * When set, prevents operations that aren't allowed in current mode.
     * - Set in DON mode when code tries to use NodeRuntime
     * - Set in Node mode when code tries to use Runtime
     */
    modeError;
    constructor(config, nextCallId, helpers, maxResponseSize, mode) {
        this.config = config;
        this.nextCallId = nextCallId;
        this.helpers = helpers;
        this.maxResponseSize = maxResponseSize;
        this.mode = mode;
    }
    /**
     * Calls a capability and returns a lazy result.
     * The actual call happens immediately, but result retrieval is deferred.
     */
    callCapability({ capabilityId, method, payload, inputSchema, outputSchema, }) {
        // Enforce mode restrictions
        if (this.modeError) {
            return {
                result: () => {
                    throw this.modeError;
                },
            };
        }
        // Allocate unique callback ID for this request
        const callbackId = this.allocateCallbackId();
        // Send request to WASM host
        const anyPayload = anyPack(inputSchema, payload);
        const req = create(CapabilityRequestSchema, {
            id: capabilityId,
            method,
            payload: anyPayload,
            callbackId,
        });
        if (!this.helpers.call(req)) {
            return {
                result: () => {
                    throw new CapabilityError(`Capability not found ${capabilityId}`, {
                        callbackId,
                        method,
                        capabilityId,
                    });
                },
            };
        }
        // Return lazy result - await and unwrap when .result() is called
        return {
            result: () => this.awaitAndUnwrapCapabilityResponse(callbackId, capabilityId, method, outputSchema),
        };
    }
    /**
     * Allocates a unique callback ID for a capability request.
     * DON mode increments, Node mode decrements (prevents collisions).
     */
    allocateCallbackId() {
        const callbackId = this.nextCallId;
        if (this.mode === Mode.DON) {
            this.nextCallId++;
        }
        else {
            this.nextCallId--;
        }
        return callbackId;
    }
    /**
     * Awaits capability response and unwraps the result or throws error.
     */
    awaitAndUnwrapCapabilityResponse(callbackId, capabilityId, method, outputSchema) {
        const awaitRequest = create(AwaitCapabilitiesRequestSchema, {
            ids: [callbackId],
        });
        const awaitResponse = this.helpers.await(awaitRequest, this.maxResponseSize);
        const capabilityResponse = awaitResponse.responses[callbackId];
        if (!capabilityResponse) {
            throw new CapabilityError(`No response found for callback ID ${callbackId}`, {
                capabilityId,
                method,
                callbackId,
            });
        }
        const response = capabilityResponse.response;
        switch (response.case) {
            case 'payload': {
                try {
                    return anyUnpack(response.value, outputSchema);
                }
                catch {
                    throw new CapabilityError(`Error cannot unwrap payload`, {
                        capabilityId,
                        method,
                        callbackId,
                    });
                }
            }
            case 'error':
                throw new CapabilityError(`Error ${response.value}`, {
                    capabilityId,
                    method,
                    callbackId,
                });
            default:
                throw new CapabilityError(`Error cannot unwrap ${response.case}`, {
                    capabilityId,
                    method,
                    callbackId,
                });
        }
    }
    getNextCallId() {
        return this.nextCallId;
    }
    now() {
        // date is already in milliseconds
        return new Date(this.helpers.now());
    }
    log(message) {
        this.helpers.log(message);
    }
}
/**
 * It is used when a BFT guarantee cannot be provided automatically (e.g. calling a standard API).
 * You tell each node to perform a task on its own.
 * Each node returns its own individual answer, and you are responsible for telling the SDK how to combine them into a single, trusted result by providing an aggregation algorithm.
 *
 * Useful in situation where you already expect non-determinism (e.g., inherently variable HTTP responses).
 * Switching from Node Mode back to DON mode requires workflow authors to handle consensus themselves.
 */
export class NodeRuntimeImpl extends BaseRuntimeImpl {
    _isNodeRuntime = true;
    constructor(config, nextCallId, helpers, maxResponseSize) {
        helpers.switchModes(Mode.NODE);
        super(config, nextCallId, helpers, maxResponseSize, Mode.NODE);
    }
}
/**
 * It is used for operations that are guaranteed to be Byzantine Fault Tolerant (BFT).
 * You ask the network to execute something, and CRE handles the underlying complexity to ensure you get back one final, secure, and trustworthy result.
 */
export class RuntimeImpl extends BaseRuntimeImpl {
    nextNodeCallId = -1;
    constructor(config, nextCallId, helpers, maxResponseSize) {
        helpers.switchModes(Mode.DON);
        super(config, nextCallId, helpers, maxResponseSize, Mode.DON);
    }
    /**
     * Executes a function in Node mode on each node, then aggregates via consensus.
     *
     * Flow:
     * 1. Switches to Node mode, preventing DON operations
     * 2. Executes fn() on each node independently
     * 3. Captures result or error as "observation"
     * 4. Switches back to DON mode
     * 5. Runs consensus to aggregate observations
     * 6. Returns aggregated result
     */
    runInNodeMode(fn, consensusAggregation, unwrapOptions) {
        return (...args) => {
            // Step 1: Create node runtime and prevent DON operations
            this.modeError = new DonModeError();
            const nodeRuntime = new NodeRuntimeImpl(this.config, this.nextNodeCallId, this.helpers, this.maxResponseSize);
            // Step 2: Prepare consensus input with config
            const consensusInput = this.prepareConsensusInput(consensusAggregation);
            // Step 3: Execute node function and capture result/error
            try {
                const observation = fn(nodeRuntime, ...args);
                this.captureObservation(consensusInput, observation, consensusAggregation.descriptor);
            }
            catch (e) {
                this.captureError(consensusInput, e);
            }
            finally {
                // Step 4: Always restore DON mode
                this.restoreDonMode(nodeRuntime);
            }
            // Step 5: Run consensus and return lazy result
            return this.runConsensusAndWrap(consensusInput, unwrapOptions);
        };
    }
    prepareConsensusInput(consensusAggregation) {
        const consensusInput = create(SimpleConsensusInputsSchema, {
            descriptors: consensusAggregation.descriptor,
        });
        if (consensusAggregation.defaultValue) {
            // Safe cast: ConsensusAggregation<T, true> implies T extends CreSerializable
            const defaultValue = Value.from(consensusAggregation.defaultValue).proto();
            clearIgnoredFields(defaultValue, consensusAggregation.descriptor);
            consensusInput.default = defaultValue;
        }
        return consensusInput;
    }
    captureObservation(consensusInput, observation, descriptor) {
        // Safe cast: ConsensusAggregation<T, true> implies T extends CreSerializable
        const observationValue = Value.from(observation).proto();
        clearIgnoredFields(observationValue, descriptor);
        consensusInput.observation = {
            case: 'value',
            value: observationValue,
        };
    }
    captureError(consensusInput, e) {
        consensusInput.observation = {
            case: 'error',
            value: (e instanceof Error && e.message) || String(e),
        };
    }
    restoreDonMode(nodeRuntime) {
        this.modeError = undefined;
        this.nextNodeCallId = nodeRuntime.nextCallId;
        nodeRuntime.modeError = new NodeModeError();
        this.helpers.switchModes(Mode.DON);
    }
    runConsensusAndWrap(consensusInput, unwrapOptions) {
        const consensus = new ConsensusCapability();
        const call = consensus.simple(this, consensusInput);
        return {
            result: () => {
                const result = call.result();
                const wrappedValue = Value.wrap(result);
                return unwrapOptions
                    ? wrappedValue.unwrapToType(unwrapOptions)
                    : wrappedValue.unwrap();
            },
        };
    }
    getSecret(request) {
        // Enforce mode restrictions
        if (this.modeError) {
            return {
                result: () => {
                    throw this.modeError;
                },
            };
        }
        // Normalize request (accept both protobuf and JSON formats)
        const secretRequest = request.$typeName
            ? request
            : create(SecretRequestSchema, request);
        // Allocate callback ID and send request
        const id = this.nextCallId;
        this.nextCallId++;
        const secretsReq = create(GetSecretsRequestSchema, {
            callbackId: id,
            requests: [secretRequest],
        });
        if (!this.helpers.getSecrets(secretsReq, this.maxResponseSize)) {
            return {
                result: () => {
                    throw new SecretsError(secretRequest, 'host is not making the secrets request');
                },
            };
        }
        // Return lazy result
        return {
            result: () => this.awaitAndUnwrapSecret(id, secretRequest),
        };
    }
    awaitAndUnwrapSecret(id, secretRequest) {
        const awaitRequest = create(AwaitSecretsRequestSchema, { ids: [id] });
        const awaitResponse = this.helpers.awaitSecrets(awaitRequest, this.maxResponseSize);
        const secretsResponse = awaitResponse.responses[id];
        if (!secretsResponse) {
            throw new SecretsError(secretRequest, 'no response');
        }
        const responses = secretsResponse.responses;
        if (responses.length !== 1) {
            throw new SecretsError(secretRequest, 'invalid value returned from host');
        }
        const response = responses[0].response;
        switch (response.case) {
            case 'secret':
                return response.value;
            case 'error':
                throw new SecretsError(secretRequest, response.value.error);
            default:
                throw new SecretsError(secretRequest, 'cannot unmarshal returned value from host');
        }
    }
    /**
     * Generates a report via consensus mechanism.
     */
    report(input) {
        const consensus = new ConsensusCapability();
        const call = consensus.report(this, input);
        return {
            result: () => call.result(),
        };
    }
}
function clearIgnoredFields(value, descriptor) {
    if (!descriptor || !value) {
        return;
    }
    const fieldsMap = descriptor.descriptor?.case === 'fieldsMap' ? descriptor.descriptor.value : undefined;
    if (!fieldsMap) {
        return;
    }
    if (value.value?.case === 'mapValue') {
        const mapValue = value.value.value;
        if (!mapValue || !mapValue.fields) {
            return;
        }
        for (const [key, val] of Object.entries(mapValue.fields)) {
            const nestedDescriptor = fieldsMap.fields[key];
            if (!nestedDescriptor) {
                delete mapValue.fields[key];
                continue;
            }
            const nestedFieldsMap = nestedDescriptor.descriptor?.case === 'fieldsMap'
                ? nestedDescriptor.descriptor.value
                : undefined;
            if (nestedFieldsMap && val.value?.case === 'mapValue') {
                clearIgnoredFields(val, nestedDescriptor);
            }
        }
    }
}
