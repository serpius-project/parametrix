import { type ConsensusDescriptor } from '../../../generated/sdk/v1alpha/sdk_pb';
import type { CreSerializable, NumericType, TypeVerifier } from './serializer_types';
export type ConsensusAggregation<T, U> = {
    readonly descriptor: ConsensusDescriptor;
    readonly defaultValue?: T;
    withDefault(t: T): ConsensusAggregation<T, U>;
    _usesUToForceShape(u: U): void;
};
export declare function consensusMedianAggregation<T extends NumericType>(): ConsensusAggregation<T, TypeVerifier<T, CreSerializable<T>>>;
export declare function consensusIdenticalAggregation<T>(): ConsensusAggregation<T, TypeVerifier<T, CreSerializable<T>>>;
export declare function consensusCommonPrefixAggregation<T>(): ConsensusAggregation<T[], TypeVerifier<T[], CreSerializable<T[]>>>;
export declare function consensusCommonSuffixAggregation<T>(): ConsensusAggregation<T[], TypeVerifier<T[], CreSerializable<T[]>>>;
export declare function median<T extends NumericType>(): ConsensusFieldAggregation<T, true>;
export declare function identical<T>(): ConsensusFieldAggregation<T, TypeVerifier<T, CreSerializable<T>>>;
export declare function commonPrefix<T>(): ConsensusFieldAggregation<T[], TypeVerifier<T[], CreSerializable<T[]>>>;
export declare function commonSuffix<T>(): ConsensusFieldAggregation<T[], TypeVerifier<T[], CreSerializable<T[]>>>;
export declare function ignore<T>(): ConsensusFieldAggregation<T, true>;
export declare class ConsensusFieldAggregation<T, U> {
    fieldDescriptor?: ConsensusDescriptor | undefined;
    protected readonly t?: T | undefined;
    protected readonly u?: U | undefined;
    constructor(fieldDescriptor?: ConsensusDescriptor | undefined, t?: T | undefined, u?: U | undefined);
}
export type ConsensusAggregationFields<T extends object> = {
    [K in keyof T as K extends '$typeName' ? never : K]: () => ConsensusFieldAggregation<T[K], true>;
};
export declare function ConsensusAggregationByFields<T extends object>(aggregation: ConsensusAggregationFields<T>): ConsensusAggregation<T, true>;
