import { fromBinary, toBinary } from '@bufbuild/protobuf';
import { AwaitCapabilitiesRequestSchema, AwaitCapabilitiesResponseSchema, AwaitSecretsRequestSchema, AwaitSecretsResponseSchema, CapabilityRequestSchema, GetSecretsRequestSchema, } from '../../generated/sdk/v1alpha/sdk_pb';
import { NodeRuntimeImpl, RuntimeImpl } from '../impl/runtime-impl';
import { hostBindings } from './host-bindings';
export class Runtime extends RuntimeImpl {
    constructor(config, nextCallId, maxResponseSize) {
        super(config, nextCallId, WasmRuntimeHelpers.getInstance(), maxResponseSize);
    }
}
export class NodeRuntime extends NodeRuntimeImpl {
    constructor(config, nextCallId, maxResponseSize) {
        super(config, nextCallId, WasmRuntimeHelpers.getInstance(), maxResponseSize);
    }
}
class WasmRuntimeHelpers {
    static instance;
    constructor() { }
    now() {
        return hostBindings.now();
    }
    static getInstance() {
        if (!WasmRuntimeHelpers.instance) {
            WasmRuntimeHelpers.instance = new WasmRuntimeHelpers();
        }
        return WasmRuntimeHelpers.instance;
    }
    call(request) {
        return hostBindings.callCapability(toBinary(CapabilityRequestSchema, request)) >= 0;
    }
    await(request, maxResponseSize) {
        // Convert bigint to integer for WASM host binding
        // it's an i32, so we shouldn't need to trunc it (all i32 numbers are within the range of float64 without percision loss), but somehow it makes a difference...
        const responseSize = Math.trunc(Number(maxResponseSize));
        const response = hostBindings.awaitCapabilities(toBinary(AwaitCapabilitiesRequestSchema, request), responseSize);
        const responseBytes = Array.isArray(response) ? new Uint8Array(response) : response;
        return fromBinary(AwaitCapabilitiesResponseSchema, responseBytes);
    }
    getSecrets(request, maxResponseSize) {
        // Convert bigint to integer for WASM host binding
        // it's an i32, so we shouldn't need to trunc it (all i32 numbers are within the range of float64 without percision loss), but somehow it makes a difference...
        const responseSize = Math.trunc(Number(maxResponseSize));
        return hostBindings.getSecrets(toBinary(GetSecretsRequestSchema, request), responseSize) >= 0;
    }
    awaitSecrets(request, maxResponseSize) {
        // Convert bigint to integer for WASM host binding
        // it's an i32, so we shouldn't need to trunc it (all i32 numbers are within the range of float64 without percision loss), but somehow it makes a difference...
        const responseSize = Math.trunc(Number(maxResponseSize));
        const response = hostBindings.awaitSecrets(toBinary(AwaitSecretsRequestSchema, request), responseSize);
        const responseBytes = Array.isArray(response) ? new Uint8Array(response) : response;
        return fromBinary(AwaitSecretsResponseSchema, responseBytes);
    }
    switchModes(mode) {
        hostBindings.switchModes(mode);
    }
    log(message) {
        hostBindings.log(message);
    }
}
