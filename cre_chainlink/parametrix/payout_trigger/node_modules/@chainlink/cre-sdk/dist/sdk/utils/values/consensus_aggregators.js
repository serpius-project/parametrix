import { create } from '@bufbuild/protobuf';
import { AggregationType, ConsensusDescriptorSchema, FieldsMapSchema, } from '../../../generated/sdk/v1alpha/sdk_pb';
// Maybe make ConsensusAggregation take a second parameter, and it'll be true or false, then make anything using it require true
// Only take one type, but make the return type ConsensusAggregation<T, TypeVerifier<T, CreSerializable<T>>
// Similar for fields, but ignore would always return ConsensusAggregationFields<T, true> instead of ConsensusAggregationFields<T, CreSerializable<T>>, and so would ConsensusAggregationByFields :D
export function consensusMedianAggregation() {
    return simpleConsensus(AggregationType.MEDIAN);
}
export function consensusIdenticalAggregation() {
    return simpleConsensus(AggregationType.IDENTICAL);
}
export function consensusCommonPrefixAggregation() {
    return simpleConsensus(AggregationType.COMMON_PREFIX);
}
export function consensusCommonSuffixAggregation() {
    return simpleConsensus(AggregationType.COMMON_SUFFIX);
}
class ConsensusImpl {
    descriptor;
    defaultValue;
    constructor(descriptor, defaultValue) {
        this.descriptor = descriptor;
        this.defaultValue = defaultValue;
    }
    withDefault(t) {
        return new ConsensusImpl(this.descriptor, t);
    }
    _usesUToForceShape(_) { }
}
function simpleConsensus(agg) {
    return new ConsensusImpl(simpleDescriptor(agg));
}
function simpleDescriptor(agg) {
    return create(ConsensusDescriptorSchema, {
        descriptor: {
            case: 'aggregation',
            value: agg,
        },
    });
}
export function median() {
    return new ConsensusFieldAggregation(simpleDescriptor(AggregationType.MEDIAN));
}
// identical requires the type twice due to limitations in circular references in TypeScripts validation system.
export function identical() {
    return new ConsensusFieldAggregation(simpleDescriptor(AggregationType.IDENTICAL));
}
export function commonPrefix() {
    return new ConsensusFieldAggregation(simpleDescriptor(AggregationType.COMMON_PREFIX));
}
export function commonSuffix() {
    return new ConsensusFieldAggregation(simpleDescriptor(AggregationType.COMMON_SUFFIX));
}
export function ignore() {
    return new ConsensusFieldAggregation();
}
export class ConsensusFieldAggregation {
    fieldDescriptor;
    t;
    u;
    // t and u are included in the constructor to force the shape of ConsensusFieldAggregation to include them.
    // This disallows automatic casting from other ConsensusFieldAggregation types.
    constructor(fieldDescriptor, t, u) {
        this.fieldDescriptor = fieldDescriptor;
        this.t = t;
        this.u = u;
    }
}
export function ConsensusAggregationByFields(aggregation) {
    const fieldMap = create(FieldsMapSchema);
    Object.keys(aggregation).forEach((key) => {
        const fieldFn = aggregation[key];
        const fieldAggregation = fieldFn();
        if (fieldAggregation.fieldDescriptor) {
            fieldMap.fields[key] = fieldAggregation.fieldDescriptor;
        }
    });
    return new ConsensusImpl(create(ConsensusDescriptorSchema, {
        descriptor: {
            case: 'fieldsMap',
            value: fieldMap,
        },
    }));
}
