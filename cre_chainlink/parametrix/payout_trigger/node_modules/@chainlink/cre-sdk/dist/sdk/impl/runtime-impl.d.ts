import { type Message } from '@bufbuild/protobuf';
import { type AwaitCapabilitiesRequest, type AwaitCapabilitiesResponse, type AwaitSecretsRequest, type AwaitSecretsResponse, type CapabilityRequest, type GetSecretsRequest, Mode, type Secret, type SecretRequest, type SecretRequestJson } from '../../generated/sdk/v1alpha/sdk_pb';
import type { BaseRuntime, CallCapabilityParams, NodeRuntime, ReportRequest, ReportRequestJson, Runtime } from '..';
import type { Report } from '../report';
import { type ConsensusAggregation, type PrimitiveTypes, type UnwrapOptions } from '../utils';
/**
 * Base implementation shared by DON and Node runtimes.
 *
 * Call ID Management:
 * - DON mode: IDs increment (1, 2, 3...)
 * - Node mode: IDs decrement (-1, -2, -3...)
 * This prevents collisions when both modes are active.
 */
export declare class BaseRuntimeImpl<C> implements BaseRuntime<C> {
    config: C;
    nextCallId: number;
    protected helpers: RuntimeHelpers;
    protected maxResponseSize: bigint;
    private mode;
    /**
     * When set, prevents operations that aren't allowed in current mode.
     * - Set in DON mode when code tries to use NodeRuntime
     * - Set in Node mode when code tries to use Runtime
     */
    modeError?: Error;
    constructor(config: C, nextCallId: number, helpers: RuntimeHelpers, maxResponseSize: bigint, mode: Mode);
    /**
     * Calls a capability and returns a lazy result.
     * The actual call happens immediately, but result retrieval is deferred.
     */
    callCapability<I extends Message, O extends Message>({ capabilityId, method, payload, inputSchema, outputSchema, }: CallCapabilityParams<I, O>): {
        result: () => O;
    };
    /**
     * Allocates a unique callback ID for a capability request.
     * DON mode increments, Node mode decrements (prevents collisions).
     */
    private allocateCallbackId;
    /**
     * Awaits capability response and unwraps the result or throws error.
     */
    private awaitAndUnwrapCapabilityResponse;
    getNextCallId(): number;
    now(): Date;
    log(message: string): void;
}
/**
 * It is used when a BFT guarantee cannot be provided automatically (e.g. calling a standard API).
 * You tell each node to perform a task on its own.
 * Each node returns its own individual answer, and you are responsible for telling the SDK how to combine them into a single, trusted result by providing an aggregation algorithm.
 *
 * Useful in situation where you already expect non-determinism (e.g., inherently variable HTTP responses).
 * Switching from Node Mode back to DON mode requires workflow authors to handle consensus themselves.
 */
export declare class NodeRuntimeImpl<C> extends BaseRuntimeImpl<C> implements NodeRuntime<C> {
    _isNodeRuntime: true;
    constructor(config: C, nextCallId: number, helpers: RuntimeHelpers, maxResponseSize: bigint);
}
/**
 * It is used for operations that are guaranteed to be Byzantine Fault Tolerant (BFT).
 * You ask the network to execute something, and CRE handles the underlying complexity to ensure you get back one final, secure, and trustworthy result.
 */
export declare class RuntimeImpl<C> extends BaseRuntimeImpl<C> implements Runtime<C> {
    private nextNodeCallId;
    constructor(config: C, nextCallId: number, helpers: RuntimeHelpers, maxResponseSize: bigint);
    /**
     * Executes a function in Node mode on each node, then aggregates via consensus.
     *
     * Flow:
     * 1. Switches to Node mode, preventing DON operations
     * 2. Executes fn() on each node independently
     * 3. Captures result or error as "observation"
     * 4. Switches back to DON mode
     * 5. Runs consensus to aggregate observations
     * 6. Returns aggregated result
     */
    runInNodeMode<TArgs extends unknown[], TOutput>(fn: (nodeRuntime: NodeRuntime<C>, ...args: TArgs) => TOutput, consensusAggregation: ConsensusAggregation<TOutput, true>, unwrapOptions?: TOutput extends PrimitiveTypes ? never : UnwrapOptions<TOutput>): (...args: TArgs) => {
        result: () => TOutput;
    };
    private prepareConsensusInput;
    private captureObservation;
    private captureError;
    private restoreDonMode;
    private runConsensusAndWrap;
    getSecret(request: SecretRequest | SecretRequestJson): {
        result: () => Secret;
    };
    private awaitAndUnwrapSecret;
    /**
     * Generates a report via consensus mechanism.
     */
    report(input: ReportRequest | ReportRequestJson): {
        result: () => Report;
    };
}
/**
 * Interface to the WASM host environment.
 * Provides low-level access to capabilities, secrets, and utilities.
 */
export interface RuntimeHelpers {
    /** Initiates a capability call. Returns false if capability not found. */
    call(request: CapabilityRequest): boolean;
    /** Awaits capability responses. Blocks until responses are ready. */
    await(request: AwaitCapabilitiesRequest, maxResponseSize: bigint): AwaitCapabilitiesResponse;
    /** Requests secrets from host. Returns false if host rejects request. */
    getSecrets(request: GetSecretsRequest, maxResponseSize: bigint): boolean;
    /** Awaits secret responses. Blocks until secrets are ready. */
    awaitSecrets(request: AwaitSecretsRequest, maxResponseSize: bigint): AwaitSecretsResponse;
    /** Switches execution mode (DON vs Node). Affects available operations. */
    switchModes(mode: Mode): void;
    /** Returns current time in milliseconds since Unix epoch. */
    now(): number;
    /** Logs a message to the host environment. */
    log(message: string): void;
}
