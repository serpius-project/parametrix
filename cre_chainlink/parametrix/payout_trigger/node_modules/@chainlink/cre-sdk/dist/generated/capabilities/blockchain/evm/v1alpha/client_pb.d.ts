import type { Message } from '@bufbuild/protobuf';
import type { GenEnum, GenFile, GenMessage, GenService } from '@bufbuild/protobuf/codegenv2';
import type { ReportResponse, ReportResponseJson } from '../../../../sdk/v1alpha/sdk_pb';
import type { BigInt, BigIntJson } from '../../../../values/v1/values_pb';
/**
 * Describes the file capabilities/blockchain/evm/v1alpha/client.proto.
 */
export declare const file_capabilities_blockchain_evm_v1alpha_client: GenFile;
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.TopicValues
 */
export type TopicValues = Message<'capabilities.blockchain.evm.v1alpha.TopicValues'> & {
    /**
     * list of possible values for any topic, in [32]byte fix-sized array format
     *
     * @generated from field: repeated bytes values = 1;
     */
    values: Uint8Array[];
};
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.TopicValues
 */
export type TopicValuesJson = {
    /**
     * list of possible values for any topic, in [32]byte fix-sized array format
     *
     * @generated from field: repeated bytes values = 1;
     */
    values?: string[];
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.TopicValues.
 * Use `create(TopicValuesSchema)` to create a new message.
 */
export declare const TopicValuesSchema: GenMessage<TopicValues, {
    jsonType: TopicValuesJson;
}>;
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.FilterLogTriggerRequest
 */
export type FilterLogTriggerRequest = Message<'capabilities.blockchain.evm.v1alpha.FilterLogTriggerRequest'> & {
    /**
     * list of addresses to include in evm address [20]byte fix-sized array format, at least one address is required
     *
     * @generated from field: repeated bytes addresses = 1;
     */
    addresses: Uint8Array[];
    /**
     *
     * TopicValues is a fixed 4 length array of possible values for any topic where:
     * a) the first element is an array of the event signatures (keccak256 of the event name and indexed args types), it has to have at least one value
     * b) the second element is an array of possible values for the first indexed argument, can be empty
     * c) the third element is an array of possible values for the second indexed argument, can be empty
     * d) the fourth element is an array of possible values for the third indexed argument, can be empty
     *
     * @generated from field: repeated capabilities.blockchain.evm.v1alpha.TopicValues topics = 2;
     */
    topics: TopicValues[];
    /**
     * optional, defaults to "SAFE"
     *
     * @generated from field: capabilities.blockchain.evm.v1alpha.ConfidenceLevel confidence = 3;
     */
    confidence: ConfidenceLevel;
};
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.FilterLogTriggerRequest
 */
export type FilterLogTriggerRequestJson = {
    /**
     * list of addresses to include in evm address [20]byte fix-sized array format, at least one address is required
     *
     * @generated from field: repeated bytes addresses = 1;
     */
    addresses?: string[];
    /**
     *
     * TopicValues is a fixed 4 length array of possible values for any topic where:
     * a) the first element is an array of the event signatures (keccak256 of the event name and indexed args types), it has to have at least one value
     * b) the second element is an array of possible values for the first indexed argument, can be empty
     * c) the third element is an array of possible values for the second indexed argument, can be empty
     * d) the fourth element is an array of possible values for the third indexed argument, can be empty
     *
     * @generated from field: repeated capabilities.blockchain.evm.v1alpha.TopicValues topics = 2;
     */
    topics?: TopicValuesJson[];
    /**
     * optional, defaults to "SAFE"
     *
     * @generated from field: capabilities.blockchain.evm.v1alpha.ConfidenceLevel confidence = 3;
     */
    confidence?: ConfidenceLevelJson;
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.FilterLogTriggerRequest.
 * Use `create(FilterLogTriggerRequestSchema)` to create a new message.
 */
export declare const FilterLogTriggerRequestSchema: GenMessage<FilterLogTriggerRequest, {
    jsonType: FilterLogTriggerRequestJson;
}>;
/**
 * CallContractRequest has arguments for reading a contract as specified in the call message at a block height defined by blockNumber where:
 * blockNumber :
 * 	nil (default) or (-2) → use the latest mined block (“latest”)
 * 	FinalizedBlockNumber(-3) → last finalized block (“finalized”)
 *
 * Any positive value is treated as an explicit block height.
 *
 * @generated from message capabilities.blockchain.evm.v1alpha.CallContractRequest
 */
export type CallContractRequest = Message<'capabilities.blockchain.evm.v1alpha.CallContractRequest'> & {
    /**
     * @generated from field: capabilities.blockchain.evm.v1alpha.CallMsg call = 1;
     */
    call?: CallMsg;
    /**
     * @generated from field: values.v1.BigInt block_number = 2;
     */
    blockNumber?: BigInt;
};
/**
 * CallContractRequest has arguments for reading a contract as specified in the call message at a block height defined by blockNumber where:
 * blockNumber :
 * 	nil (default) or (-2) → use the latest mined block (“latest”)
 * 	FinalizedBlockNumber(-3) → last finalized block (“finalized”)
 *
 * Any positive value is treated as an explicit block height.
 *
 * @generated from message capabilities.blockchain.evm.v1alpha.CallContractRequest
 */
export type CallContractRequestJson = {
    /**
     * @generated from field: capabilities.blockchain.evm.v1alpha.CallMsg call = 1;
     */
    call?: CallMsgJson;
    /**
     * @generated from field: values.v1.BigInt block_number = 2;
     */
    blockNumber?: BigIntJson;
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.CallContractRequest.
 * Use `create(CallContractRequestSchema)` to create a new message.
 */
export declare const CallContractRequestSchema: GenMessage<CallContractRequest, {
    jsonType: CallContractRequestJson;
}>;
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.CallContractReply
 */
export type CallContractReply = Message<'capabilities.blockchain.evm.v1alpha.CallContractReply'> & {
    /**
     * solidity-spec abi encoded bytes
     *
     * @generated from field: bytes data = 1;
     */
    data: Uint8Array;
};
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.CallContractReply
 */
export type CallContractReplyJson = {
    /**
     * solidity-spec abi encoded bytes
     *
     * @generated from field: bytes data = 1;
     */
    data?: string;
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.CallContractReply.
 * Use `create(CallContractReplySchema)` to create a new message.
 */
export declare const CallContractReplySchema: GenMessage<CallContractReply, {
    jsonType: CallContractReplyJson;
}>;
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.FilterLogsRequest
 */
export type FilterLogsRequest = Message<'capabilities.blockchain.evm.v1alpha.FilterLogsRequest'> & {
    /**
     * @generated from field: capabilities.blockchain.evm.v1alpha.FilterQuery filter_query = 1;
     */
    filterQuery?: FilterQuery;
};
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.FilterLogsRequest
 */
export type FilterLogsRequestJson = {
    /**
     * @generated from field: capabilities.blockchain.evm.v1alpha.FilterQuery filter_query = 1;
     */
    filterQuery?: FilterQueryJson;
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.FilterLogsRequest.
 * Use `create(FilterLogsRequestSchema)` to create a new message.
 */
export declare const FilterLogsRequestSchema: GenMessage<FilterLogsRequest, {
    jsonType: FilterLogsRequestJson;
}>;
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.FilterLogsReply
 */
export type FilterLogsReply = Message<'capabilities.blockchain.evm.v1alpha.FilterLogsReply'> & {
    /**
     * @generated from field: repeated capabilities.blockchain.evm.v1alpha.Log logs = 1;
     */
    logs: Log[];
};
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.FilterLogsReply
 */
export type FilterLogsReplyJson = {
    /**
     * @generated from field: repeated capabilities.blockchain.evm.v1alpha.Log logs = 1;
     */
    logs?: LogJson[];
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.FilterLogsReply.
 * Use `create(FilterLogsReplySchema)` to create a new message.
 */
export declare const FilterLogsReplySchema: GenMessage<FilterLogsReply, {
    jsonType: FilterLogsReplyJson;
}>;
/**
 * represents evm-style log
 *
 * @generated from message capabilities.blockchain.evm.v1alpha.Log
 */
export type Log = Message<'capabilities.blockchain.evm.v1alpha.Log'> & {
    /**
     * address of the contract emitted the log in evm address [20]byte fix-sized array format
     *
     * @generated from field: bytes address = 1;
     */
    address: Uint8Array;
    /**
     * indexed log fields, in [32]byte fix-sized array format
     *
     * @generated from field: repeated bytes topics = 2;
     */
    topics: Uint8Array[];
    /**
     * hash of the transaction containing the log, in [32]byte fix-sized array format
     *
     * @generated from field: bytes tx_hash = 3;
     */
    txHash: Uint8Array;
    /**
     * hash of the block containing the log, in [32]byte fix-sized array format
     *
     * @generated from field: bytes block_hash = 4;
     */
    blockHash: Uint8Array;
    /**
     * solidity-spec abi encoded log Data
     *
     * @generated from field: bytes data = 5;
     */
    data: Uint8Array;
    /**
     * keccak256 of event signature, in [32]byte fix-sized array format
     *
     * @generated from field: bytes event_sig = 6;
     */
    eventSig: Uint8Array;
    /**
     * block number containing the log
     *
     * @generated from field: values.v1.BigInt block_number = 7;
     */
    blockNumber?: BigInt;
    /**
     * index of transaction emmited the log
     *
     * @generated from field: uint32 tx_index = 8;
     */
    txIndex: number;
    /**
     * index of the Log within the intire block
     *
     * @generated from field: uint32 index = 9;
     */
    index: number;
    /**
     * flag if the log was removed during reorg
     *
     * @generated from field: bool removed = 10;
     */
    removed: boolean;
};
/**
 * represents evm-style log
 *
 * @generated from message capabilities.blockchain.evm.v1alpha.Log
 */
export type LogJson = {
    /**
     * address of the contract emitted the log in evm address [20]byte fix-sized array format
     *
     * @generated from field: bytes address = 1;
     */
    address?: string;
    /**
     * indexed log fields, in [32]byte fix-sized array format
     *
     * @generated from field: repeated bytes topics = 2;
     */
    topics?: string[];
    /**
     * hash of the transaction containing the log, in [32]byte fix-sized array format
     *
     * @generated from field: bytes tx_hash = 3;
     */
    txHash?: string;
    /**
     * hash of the block containing the log, in [32]byte fix-sized array format
     *
     * @generated from field: bytes block_hash = 4;
     */
    blockHash?: string;
    /**
     * solidity-spec abi encoded log Data
     *
     * @generated from field: bytes data = 5;
     */
    data?: string;
    /**
     * keccak256 of event signature, in [32]byte fix-sized array format
     *
     * @generated from field: bytes event_sig = 6;
     */
    eventSig?: string;
    /**
     * block number containing the log
     *
     * @generated from field: values.v1.BigInt block_number = 7;
     */
    blockNumber?: BigIntJson;
    /**
     * index of transaction emmited the log
     *
     * @generated from field: uint32 tx_index = 8;
     */
    txIndex?: number;
    /**
     * index of the Log within the intire block
     *
     * @generated from field: uint32 index = 9;
     */
    index?: number;
    /**
     * flag if the log was removed during reorg
     *
     * @generated from field: bool removed = 10;
     */
    removed?: boolean;
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.Log.
 * Use `create(LogSchema)` to create a new message.
 */
export declare const LogSchema: GenMessage<Log, {
    jsonType: LogJson;
}>;
/**
 * represents simplified evm-style CallMsg
 *
 * @generated from message capabilities.blockchain.evm.v1alpha.CallMsg
 */
export type CallMsg = Message<'capabilities.blockchain.evm.v1alpha.CallMsg'> & {
    /**
     * sender address in evm address [20]byte fix-sized array format
     *
     * @generated from field: bytes from = 1;
     */
    from: Uint8Array;
    /**
     * contract address in evm address [20]byte fix-sized array format
     *
     * @generated from field: bytes to = 2;
     */
    to: Uint8Array;
    /**
     * solidity-spec abi encoded bytes
     *
     * @generated from field: bytes data = 3;
     */
    data: Uint8Array;
};
/**
 * represents simplified evm-style CallMsg
 *
 * @generated from message capabilities.blockchain.evm.v1alpha.CallMsg
 */
export type CallMsgJson = {
    /**
     * sender address in evm address [20]byte fix-sized array format
     *
     * @generated from field: bytes from = 1;
     */
    from?: string;
    /**
     * contract address in evm address [20]byte fix-sized array format
     *
     * @generated from field: bytes to = 2;
     */
    to?: string;
    /**
     * solidity-spec abi encoded bytes
     *
     * @generated from field: bytes data = 3;
     */
    data?: string;
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.CallMsg.
 * Use `create(CallMsgSchema)` to create a new message.
 */
export declare const CallMsgSchema: GenMessage<CallMsg, {
    jsonType: CallMsgJson;
}>;
/**
 * represents evm-style filter query
 *
 * @generated from message capabilities.blockchain.evm.v1alpha.FilterQuery
 */
export type FilterQuery = Message<'capabilities.blockchain.evm.v1alpha.FilterQuery'> & {
    /**
     * exact block (cant use from/to), in [32]byte fix-sized array format
     *
     * @generated from field: bytes block_hash = 1;
     */
    blockHash: Uint8Array;
    /**
     * start block range
     *
     * @generated from field: values.v1.BigInt from_block = 2;
     */
    fromBlock?: BigInt;
    /**
     * end block range
     *
     * @generated from field: values.v1.BigInt to_block = 3;
     */
    toBlock?: BigInt;
    /**
     * contract(s) to filter logs from in evm address [20]byte fix-sized array format
     *
     * @generated from field: repeated bytes addresses = 4;
     */
    addresses: Uint8Array[];
    /**
     * filter log by event signature and indexed args
     *
     * @generated from field: repeated capabilities.blockchain.evm.v1alpha.Topics topics = 5;
     */
    topics: Topics[];
};
/**
 * represents evm-style filter query
 *
 * @generated from message capabilities.blockchain.evm.v1alpha.FilterQuery
 */
export type FilterQueryJson = {
    /**
     * exact block (cant use from/to), in [32]byte fix-sized array format
     *
     * @generated from field: bytes block_hash = 1;
     */
    blockHash?: string;
    /**
     * start block range
     *
     * @generated from field: values.v1.BigInt from_block = 2;
     */
    fromBlock?: BigIntJson;
    /**
     * end block range
     *
     * @generated from field: values.v1.BigInt to_block = 3;
     */
    toBlock?: BigIntJson;
    /**
     * contract(s) to filter logs from in evm address [20]byte fix-sized array format
     *
     * @generated from field: repeated bytes addresses = 4;
     */
    addresses?: string[];
    /**
     * filter log by event signature and indexed args
     *
     * @generated from field: repeated capabilities.blockchain.evm.v1alpha.Topics topics = 5;
     */
    topics?: TopicsJson[];
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.FilterQuery.
 * Use `create(FilterQuerySchema)` to create a new message.
 */
export declare const FilterQuerySchema: GenMessage<FilterQuery, {
    jsonType: FilterQueryJson;
}>;
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.Topics
 */
export type Topics = Message<'capabilities.blockchain.evm.v1alpha.Topics'> & {
    /**
     * in [32]byte fix-sized array format
     *
     * @generated from field: repeated bytes topic = 1;
     */
    topic: Uint8Array[];
};
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.Topics
 */
export type TopicsJson = {
    /**
     * in [32]byte fix-sized array format
     *
     * @generated from field: repeated bytes topic = 1;
     */
    topic?: string[];
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.Topics.
 * Use `create(TopicsSchema)` to create a new message.
 */
export declare const TopicsSchema: GenMessage<Topics, {
    jsonType: TopicsJson;
}>;
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.BalanceAtRequest
 */
export type BalanceAtRequest = Message<'capabilities.blockchain.evm.v1alpha.BalanceAtRequest'> & {
    /**
     * in evm address [20]byte fix-sized array format
     *
     * @generated from field: bytes account = 1;
     */
    account: Uint8Array;
    /**
     * @generated from field: values.v1.BigInt block_number = 2;
     */
    blockNumber?: BigInt;
};
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.BalanceAtRequest
 */
export type BalanceAtRequestJson = {
    /**
     * in evm address [20]byte fix-sized array format
     *
     * @generated from field: bytes account = 1;
     */
    account?: string;
    /**
     * @generated from field: values.v1.BigInt block_number = 2;
     */
    blockNumber?: BigIntJson;
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.BalanceAtRequest.
 * Use `create(BalanceAtRequestSchema)` to create a new message.
 */
export declare const BalanceAtRequestSchema: GenMessage<BalanceAtRequest, {
    jsonType: BalanceAtRequestJson;
}>;
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.BalanceAtReply
 */
export type BalanceAtReply = Message<'capabilities.blockchain.evm.v1alpha.BalanceAtReply'> & {
    /**
     * Balance of the account in wei (10^-18 eth)
     *
     * @generated from field: values.v1.BigInt balance = 1;
     */
    balance?: BigInt;
};
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.BalanceAtReply
 */
export type BalanceAtReplyJson = {
    /**
     * Balance of the account in wei (10^-18 eth)
     *
     * @generated from field: values.v1.BigInt balance = 1;
     */
    balance?: BigIntJson;
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.BalanceAtReply.
 * Use `create(BalanceAtReplySchema)` to create a new message.
 */
export declare const BalanceAtReplySchema: GenMessage<BalanceAtReply, {
    jsonType: BalanceAtReplyJson;
}>;
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.EstimateGasRequest
 */
export type EstimateGasRequest = Message<'capabilities.blockchain.evm.v1alpha.EstimateGasRequest'> & {
    /**
     * simulates tx execution returns approximate amount of gas units needed
     *
     * @generated from field: capabilities.blockchain.evm.v1alpha.CallMsg msg = 1;
     */
    msg?: CallMsg;
};
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.EstimateGasRequest
 */
export type EstimateGasRequestJson = {
    /**
     * simulates tx execution returns approximate amount of gas units needed
     *
     * @generated from field: capabilities.blockchain.evm.v1alpha.CallMsg msg = 1;
     */
    msg?: CallMsgJson;
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.EstimateGasRequest.
 * Use `create(EstimateGasRequestSchema)` to create a new message.
 */
export declare const EstimateGasRequestSchema: GenMessage<EstimateGasRequest, {
    jsonType: EstimateGasRequestJson;
}>;
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.EstimateGasReply
 */
export type EstimateGasReply = Message<'capabilities.blockchain.evm.v1alpha.EstimateGasReply'> & {
    /**
     * estimated amount of gas in gas units, needed for tx execution
     *
     * @generated from field: uint64 gas = 1 [jstype = JS_NORMAL];
     */
    gas: bigint;
};
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.EstimateGasReply
 */
export type EstimateGasReplyJson = {
    /**
     * estimated amount of gas in gas units, needed for tx execution
     *
     * @generated from field: uint64 gas = 1 [jstype = JS_NORMAL];
     */
    gas?: string;
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.EstimateGasReply.
 * Use `create(EstimateGasReplySchema)` to create a new message.
 */
export declare const EstimateGasReplySchema: GenMessage<EstimateGasReply, {
    jsonType: EstimateGasReplyJson;
}>;
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.GetTransactionByHashRequest
 */
export type GetTransactionByHashRequest = Message<'capabilities.blockchain.evm.v1alpha.GetTransactionByHashRequest'> & {
    /**
     * in [32]byte fix-sized array format
     *
     * @generated from field: bytes hash = 1;
     */
    hash: Uint8Array;
};
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.GetTransactionByHashRequest
 */
export type GetTransactionByHashRequestJson = {
    /**
     * in [32]byte fix-sized array format
     *
     * @generated from field: bytes hash = 1;
     */
    hash?: string;
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.GetTransactionByHashRequest.
 * Use `create(GetTransactionByHashRequestSchema)` to create a new message.
 */
export declare const GetTransactionByHashRequestSchema: GenMessage<GetTransactionByHashRequest, {
    jsonType: GetTransactionByHashRequestJson;
}>;
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.GetTransactionByHashReply
 */
export type GetTransactionByHashReply = Message<'capabilities.blockchain.evm.v1alpha.GetTransactionByHashReply'> & {
    /**
     * @generated from field: capabilities.blockchain.evm.v1alpha.Transaction transaction = 1;
     */
    transaction?: Transaction;
};
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.GetTransactionByHashReply
 */
export type GetTransactionByHashReplyJson = {
    /**
     * @generated from field: capabilities.blockchain.evm.v1alpha.Transaction transaction = 1;
     */
    transaction?: TransactionJson;
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.GetTransactionByHashReply.
 * Use `create(GetTransactionByHashReplySchema)` to create a new message.
 */
export declare const GetTransactionByHashReplySchema: GenMessage<GetTransactionByHashReply, {
    jsonType: GetTransactionByHashReplyJson;
}>;
/**
 * represents evm-style transaction
 *
 * @generated from message capabilities.blockchain.evm.v1alpha.Transaction
 */
export type Transaction = Message<'capabilities.blockchain.evm.v1alpha.Transaction'> & {
    /**
     * number of txs sent from sender
     *
     * @generated from field: uint64 nonce = 1 [jstype = JS_NORMAL];
     */
    nonce: bigint;
    /**
     * max gas allowed per execution (in gas units)
     *
     * @generated from field: uint64 gas = 2 [jstype = JS_NORMAL];
     */
    gas: bigint;
    /**
     * recipient address in evm address [20]byte fix-sized array format
     *
     * @generated from field: bytes to = 3;
     */
    to: Uint8Array;
    /**
     * solidity-spec abi encoded input data for function call payload
     *
     * @generated from field: bytes data = 4;
     */
    data: Uint8Array;
    /**
     * transaction hash, in [32]byte fix-sized array format
     *
     * @generated from field: bytes hash = 5;
     */
    hash: Uint8Array;
    /**
     * amount of eth sent in wei
     *
     * @generated from field: values.v1.BigInt value = 6;
     */
    value?: BigInt;
    /**
     * price for a single gas unit in wei
     *
     * @generated from field: values.v1.BigInt gas_price = 7;
     */
    gasPrice?: BigInt;
};
/**
 * represents evm-style transaction
 *
 * @generated from message capabilities.blockchain.evm.v1alpha.Transaction
 */
export type TransactionJson = {
    /**
     * number of txs sent from sender
     *
     * @generated from field: uint64 nonce = 1 [jstype = JS_NORMAL];
     */
    nonce?: string;
    /**
     * max gas allowed per execution (in gas units)
     *
     * @generated from field: uint64 gas = 2 [jstype = JS_NORMAL];
     */
    gas?: string;
    /**
     * recipient address in evm address [20]byte fix-sized array format
     *
     * @generated from field: bytes to = 3;
     */
    to?: string;
    /**
     * solidity-spec abi encoded input data for function call payload
     *
     * @generated from field: bytes data = 4;
     */
    data?: string;
    /**
     * transaction hash, in [32]byte fix-sized array format
     *
     * @generated from field: bytes hash = 5;
     */
    hash?: string;
    /**
     * amount of eth sent in wei
     *
     * @generated from field: values.v1.BigInt value = 6;
     */
    value?: BigIntJson;
    /**
     * price for a single gas unit in wei
     *
     * @generated from field: values.v1.BigInt gas_price = 7;
     */
    gasPrice?: BigIntJson;
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.Transaction.
 * Use `create(TransactionSchema)` to create a new message.
 */
export declare const TransactionSchema: GenMessage<Transaction, {
    jsonType: TransactionJson;
}>;
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.GetTransactionReceiptRequest
 */
export type GetTransactionReceiptRequest = Message<'capabilities.blockchain.evm.v1alpha.GetTransactionReceiptRequest'> & {
    /**
     * in [32]byte fix-sized array format
     *
     * @generated from field: bytes hash = 1;
     */
    hash: Uint8Array;
};
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.GetTransactionReceiptRequest
 */
export type GetTransactionReceiptRequestJson = {
    /**
     * in [32]byte fix-sized array format
     *
     * @generated from field: bytes hash = 1;
     */
    hash?: string;
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.GetTransactionReceiptRequest.
 * Use `create(GetTransactionReceiptRequestSchema)` to create a new message.
 */
export declare const GetTransactionReceiptRequestSchema: GenMessage<GetTransactionReceiptRequest, {
    jsonType: GetTransactionReceiptRequestJson;
}>;
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.GetTransactionReceiptReply
 */
export type GetTransactionReceiptReply = Message<'capabilities.blockchain.evm.v1alpha.GetTransactionReceiptReply'> & {
    /**
     * @generated from field: capabilities.blockchain.evm.v1alpha.Receipt receipt = 1;
     */
    receipt?: Receipt;
};
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.GetTransactionReceiptReply
 */
export type GetTransactionReceiptReplyJson = {
    /**
     * @generated from field: capabilities.blockchain.evm.v1alpha.Receipt receipt = 1;
     */
    receipt?: ReceiptJson;
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.GetTransactionReceiptReply.
 * Use `create(GetTransactionReceiptReplySchema)` to create a new message.
 */
export declare const GetTransactionReceiptReplySchema: GenMessage<GetTransactionReceiptReply, {
    jsonType: GetTransactionReceiptReplyJson;
}>;
/**
 * represents evm-style receipt
 *
 * @generated from message capabilities.blockchain.evm.v1alpha.Receipt
 */
export type Receipt = Message<'capabilities.blockchain.evm.v1alpha.Receipt'> & {
    /**
     * 1 for success 0 for failure
     *
     * @generated from field: uint64 status = 1 [jstype = JS_NORMAL];
     */
    status: bigint;
    /**
     * gas used by this transaction (in gas units)
     *
     * @generated from field: uint64 gas_used = 2 [jstype = JS_NORMAL];
     */
    gasUsed: bigint;
    /**
     * index of the transaction inside of the block
     *
     * @generated from field: uint64 tx_index = 3 [jstype = JS_NORMAL];
     */
    txIndex: bigint;
    /**
     * block hash containing the transaction
     *
     * @generated from field: bytes block_hash = 4;
     */
    blockHash: Uint8Array;
    /**
     * logs emitted by this transaction
     *
     * @generated from field: repeated capabilities.blockchain.evm.v1alpha.Log logs = 6;
     */
    logs: Log[];
    /**
     * hash of the transaction this receipt is for, in [32]byte fix-sized array format
     *
     * @generated from field: bytes tx_hash = 7;
     */
    txHash: Uint8Array;
    /**
     * actual gas price paid in wei (include after EIP-1559)
     *
     * @generated from field: values.v1.BigInt effective_gas_price = 8;
     */
    effectiveGasPrice?: BigInt;
    /**
     * block number containing the transaction
     *
     * @generated from field: values.v1.BigInt block_number = 9;
     */
    blockNumber?: BigInt;
    /**
     * address of the contract if this transaction created one in evm address [20]byte fix-sized array format
     *
     * @generated from field: bytes contract_address = 10;
     */
    contractAddress: Uint8Array;
};
/**
 * represents evm-style receipt
 *
 * @generated from message capabilities.blockchain.evm.v1alpha.Receipt
 */
export type ReceiptJson = {
    /**
     * 1 for success 0 for failure
     *
     * @generated from field: uint64 status = 1 [jstype = JS_NORMAL];
     */
    status?: string;
    /**
     * gas used by this transaction (in gas units)
     *
     * @generated from field: uint64 gas_used = 2 [jstype = JS_NORMAL];
     */
    gasUsed?: string;
    /**
     * index of the transaction inside of the block
     *
     * @generated from field: uint64 tx_index = 3 [jstype = JS_NORMAL];
     */
    txIndex?: string;
    /**
     * block hash containing the transaction
     *
     * @generated from field: bytes block_hash = 4;
     */
    blockHash?: string;
    /**
     * logs emitted by this transaction
     *
     * @generated from field: repeated capabilities.blockchain.evm.v1alpha.Log logs = 6;
     */
    logs?: LogJson[];
    /**
     * hash of the transaction this receipt is for, in [32]byte fix-sized array format
     *
     * @generated from field: bytes tx_hash = 7;
     */
    txHash?: string;
    /**
     * actual gas price paid in wei (include after EIP-1559)
     *
     * @generated from field: values.v1.BigInt effective_gas_price = 8;
     */
    effectiveGasPrice?: BigIntJson;
    /**
     * block number containing the transaction
     *
     * @generated from field: values.v1.BigInt block_number = 9;
     */
    blockNumber?: BigIntJson;
    /**
     * address of the contract if this transaction created one in evm address [20]byte fix-sized array format
     *
     * @generated from field: bytes contract_address = 10;
     */
    contractAddress?: string;
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.Receipt.
 * Use `create(ReceiptSchema)` to create a new message.
 */
export declare const ReceiptSchema: GenMessage<Receipt, {
    jsonType: ReceiptJson;
}>;
/**
 * ----- Request/Reply Wrappers -----
 *
 * @generated from message capabilities.blockchain.evm.v1alpha.HeaderByNumberRequest
 */
export type HeaderByNumberRequest = Message<'capabilities.blockchain.evm.v1alpha.HeaderByNumberRequest'> & {
    /**
     * @generated from field: values.v1.BigInt block_number = 1;
     */
    blockNumber?: BigInt;
};
/**
 * ----- Request/Reply Wrappers -----
 *
 * @generated from message capabilities.blockchain.evm.v1alpha.HeaderByNumberRequest
 */
export type HeaderByNumberRequestJson = {
    /**
     * @generated from field: values.v1.BigInt block_number = 1;
     */
    blockNumber?: BigIntJson;
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.HeaderByNumberRequest.
 * Use `create(HeaderByNumberRequestSchema)` to create a new message.
 */
export declare const HeaderByNumberRequestSchema: GenMessage<HeaderByNumberRequest, {
    jsonType: HeaderByNumberRequestJson;
}>;
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.HeaderByNumberReply
 */
export type HeaderByNumberReply = Message<'capabilities.blockchain.evm.v1alpha.HeaderByNumberReply'> & {
    /**
     * @generated from field: capabilities.blockchain.evm.v1alpha.Header header = 1;
     */
    header?: Header;
};
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.HeaderByNumberReply
 */
export type HeaderByNumberReplyJson = {
    /**
     * @generated from field: capabilities.blockchain.evm.v1alpha.Header header = 1;
     */
    header?: HeaderJson;
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.HeaderByNumberReply.
 * Use `create(HeaderByNumberReplySchema)` to create a new message.
 */
export declare const HeaderByNumberReplySchema: GenMessage<HeaderByNumberReply, {
    jsonType: HeaderByNumberReplyJson;
}>;
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.Header
 */
export type Header = Message<'capabilities.blockchain.evm.v1alpha.Header'> & {
    /**
     * unix timestamp
     *
     * @generated from field: uint64 timestamp = 1 [jstype = JS_NORMAL];
     */
    timestamp: bigint;
    /**
     * @generated from field: values.v1.BigInt block_number = 2;
     */
    blockNumber?: BigInt;
    /**
     * in [32]byte fix-sized array format
     *
     * @generated from field: bytes hash = 3;
     */
    hash: Uint8Array;
    /**
     * in [32]byte fix-sized array format
     *
     * @generated from field: bytes parent_hash = 4;
     */
    parentHash: Uint8Array;
};
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.Header
 */
export type HeaderJson = {
    /**
     * unix timestamp
     *
     * @generated from field: uint64 timestamp = 1 [jstype = JS_NORMAL];
     */
    timestamp?: string;
    /**
     * @generated from field: values.v1.BigInt block_number = 2;
     */
    blockNumber?: BigIntJson;
    /**
     * in [32]byte fix-sized array format
     *
     * @generated from field: bytes hash = 3;
     */
    hash?: string;
    /**
     * in [32]byte fix-sized array format
     *
     * @generated from field: bytes parent_hash = 4;
     */
    parentHash?: string;
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.Header.
 * Use `create(HeaderSchema)` to create a new message.
 */
export declare const HeaderSchema: GenMessage<Header, {
    jsonType: HeaderJson;
}>;
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.WriteReportRequest
 */
export type WriteReportRequest = Message<'capabilities.blockchain.evm.v1alpha.WriteReportRequest'> & {
    /**
     * @generated from field: bytes receiver = 1;
     */
    receiver: Uint8Array;
    /**
     * @generated from field: sdk.v1alpha.ReportResponse report = 2;
     */
    report?: ReportResponse;
    /**
     * @generated from field: optional capabilities.blockchain.evm.v1alpha.GasConfig gas_config = 3;
     */
    gasConfig?: GasConfig;
};
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.WriteReportRequest
 */
export type WriteReportRequestJson = {
    /**
     * @generated from field: bytes receiver = 1;
     */
    receiver?: string;
    /**
     * @generated from field: sdk.v1alpha.ReportResponse report = 2;
     */
    report?: ReportResponseJson;
    /**
     * @generated from field: optional capabilities.blockchain.evm.v1alpha.GasConfig gas_config = 3;
     */
    gasConfig?: GasConfigJson;
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.WriteReportRequest.
 * Use `create(WriteReportRequestSchema)` to create a new message.
 */
export declare const WriteReportRequestSchema: GenMessage<WriteReportRequest, {
    jsonType: WriteReportRequestJson;
}>;
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.GasConfig
 */
export type GasConfig = Message<'capabilities.blockchain.evm.v1alpha.GasConfig'> & {
    /**
     * @generated from field: uint64 gas_limit = 1 [jstype = JS_NORMAL];
     */
    gasLimit: bigint;
};
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.GasConfig
 */
export type GasConfigJson = {
    /**
     * @generated from field: uint64 gas_limit = 1 [jstype = JS_NORMAL];
     */
    gasLimit?: string;
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.GasConfig.
 * Use `create(GasConfigSchema)` to create a new message.
 */
export declare const GasConfigSchema: GenMessage<GasConfig, {
    jsonType: GasConfigJson;
}>;
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.WriteReportReply
 */
export type WriteReportReply = Message<'capabilities.blockchain.evm.v1alpha.WriteReportReply'> & {
    /**
     * @generated from field: capabilities.blockchain.evm.v1alpha.TxStatus tx_status = 1;
     */
    txStatus: TxStatus;
    /**
     * @generated from field: optional capabilities.blockchain.evm.v1alpha.ReceiverContractExecutionStatus receiver_contract_execution_status = 2;
     */
    receiverContractExecutionStatus?: ReceiverContractExecutionStatus;
    /**
     * @generated from field: optional bytes tx_hash = 3;
     */
    txHash?: Uint8Array;
    /**
     * @generated from field: optional values.v1.BigInt transaction_fee = 4;
     */
    transactionFee?: BigInt;
    /**
     * @generated from field: optional string error_message = 5;
     */
    errorMessage?: string;
};
/**
 * @generated from message capabilities.blockchain.evm.v1alpha.WriteReportReply
 */
export type WriteReportReplyJson = {
    /**
     * @generated from field: capabilities.blockchain.evm.v1alpha.TxStatus tx_status = 1;
     */
    txStatus?: TxStatusJson;
    /**
     * @generated from field: optional capabilities.blockchain.evm.v1alpha.ReceiverContractExecutionStatus receiver_contract_execution_status = 2;
     */
    receiverContractExecutionStatus?: ReceiverContractExecutionStatusJson;
    /**
     * @generated from field: optional bytes tx_hash = 3;
     */
    txHash?: string;
    /**
     * @generated from field: optional values.v1.BigInt transaction_fee = 4;
     */
    transactionFee?: BigIntJson;
    /**
     * @generated from field: optional string error_message = 5;
     */
    errorMessage?: string;
};
/**
 * Describes the message capabilities.blockchain.evm.v1alpha.WriteReportReply.
 * Use `create(WriteReportReplySchema)` to create a new message.
 */
export declare const WriteReportReplySchema: GenMessage<WriteReportReply, {
    jsonType: WriteReportReplyJson;
}>;
/**
 * @generated from enum capabilities.blockchain.evm.v1alpha.ConfidenceLevel
 */
export declare enum ConfidenceLevel {
    /**
     * @generated from enum value: CONFIDENCE_LEVEL_SAFE = 0;
     */
    SAFE = 0,
    /**
     * @generated from enum value: CONFIDENCE_LEVEL_LATEST = 1;
     */
    LATEST = 1,
    /**
     * @generated from enum value: CONFIDENCE_LEVEL_FINALIZED = 2;
     */
    FINALIZED = 2
}
/**
 * @generated from enum capabilities.blockchain.evm.v1alpha.ConfidenceLevel
 */
export type ConfidenceLevelJson = 'CONFIDENCE_LEVEL_SAFE' | 'CONFIDENCE_LEVEL_LATEST' | 'CONFIDENCE_LEVEL_FINALIZED';
/**
 * Describes the enum capabilities.blockchain.evm.v1alpha.ConfidenceLevel.
 */
export declare const ConfidenceLevelSchema: GenEnum<ConfidenceLevel, ConfidenceLevelJson>;
/**
 * @generated from enum capabilities.blockchain.evm.v1alpha.ReceiverContractExecutionStatus
 */
export declare enum ReceiverContractExecutionStatus {
    /**
     * @generated from enum value: RECEIVER_CONTRACT_EXECUTION_STATUS_SUCCESS = 0;
     */
    SUCCESS = 0,
    /**
     * @generated from enum value: RECEIVER_CONTRACT_EXECUTION_STATUS_REVERTED = 1;
     */
    REVERTED = 1
}
/**
 * @generated from enum capabilities.blockchain.evm.v1alpha.ReceiverContractExecutionStatus
 */
export type ReceiverContractExecutionStatusJson = 'RECEIVER_CONTRACT_EXECUTION_STATUS_SUCCESS' | 'RECEIVER_CONTRACT_EXECUTION_STATUS_REVERTED';
/**
 * Describes the enum capabilities.blockchain.evm.v1alpha.ReceiverContractExecutionStatus.
 */
export declare const ReceiverContractExecutionStatusSchema: GenEnum<ReceiverContractExecutionStatus, ReceiverContractExecutionStatusJson>;
/**
 * @generated from enum capabilities.blockchain.evm.v1alpha.TxStatus
 */
export declare enum TxStatus {
    /**
     * @generated from enum value: TX_STATUS_FATAL = 0;
     */
    FATAL = 0,
    /**
     * @generated from enum value: TX_STATUS_REVERTED = 1;
     */
    REVERTED = 1,
    /**
     * @generated from enum value: TX_STATUS_SUCCESS = 2;
     */
    SUCCESS = 2
}
/**
 * @generated from enum capabilities.blockchain.evm.v1alpha.TxStatus
 */
export type TxStatusJson = 'TX_STATUS_FATAL' | 'TX_STATUS_REVERTED' | 'TX_STATUS_SUCCESS';
/**
 * Describes the enum capabilities.blockchain.evm.v1alpha.TxStatus.
 */
export declare const TxStatusSchema: GenEnum<TxStatus, TxStatusJson>;
/**
 * @generated from service capabilities.blockchain.evm.v1alpha.Client
 */
export declare const Client: GenService<{
    /**
     * @generated from rpc capabilities.blockchain.evm.v1alpha.Client.CallContract
     */
    callContract: {
        methodKind: 'unary';
        input: typeof CallContractRequestSchema;
        output: typeof CallContractReplySchema;
    };
    /**
     * @generated from rpc capabilities.blockchain.evm.v1alpha.Client.FilterLogs
     */
    filterLogs: {
        methodKind: 'unary';
        input: typeof FilterLogsRequestSchema;
        output: typeof FilterLogsReplySchema;
    };
    /**
     * @generated from rpc capabilities.blockchain.evm.v1alpha.Client.BalanceAt
     */
    balanceAt: {
        methodKind: 'unary';
        input: typeof BalanceAtRequestSchema;
        output: typeof BalanceAtReplySchema;
    };
    /**
     * @generated from rpc capabilities.blockchain.evm.v1alpha.Client.EstimateGas
     */
    estimateGas: {
        methodKind: 'unary';
        input: typeof EstimateGasRequestSchema;
        output: typeof EstimateGasReplySchema;
    };
    /**
     * @generated from rpc capabilities.blockchain.evm.v1alpha.Client.GetTransactionByHash
     */
    getTransactionByHash: {
        methodKind: 'unary';
        input: typeof GetTransactionByHashRequestSchema;
        output: typeof GetTransactionByHashReplySchema;
    };
    /**
     * @generated from rpc capabilities.blockchain.evm.v1alpha.Client.GetTransactionReceipt
     */
    getTransactionReceipt: {
        methodKind: 'unary';
        input: typeof GetTransactionReceiptRequestSchema;
        output: typeof GetTransactionReceiptReplySchema;
    };
    /**
     * @generated from rpc capabilities.blockchain.evm.v1alpha.Client.HeaderByNumber
     */
    headerByNumber: {
        methodKind: 'unary';
        input: typeof HeaderByNumberRequestSchema;
        output: typeof HeaderByNumberReplySchema;
    };
    /**
     * @generated from rpc capabilities.blockchain.evm.v1alpha.Client.LogTrigger
     */
    logTrigger: {
        methodKind: 'server_streaming';
        input: typeof FilterLogTriggerRequestSchema;
        output: typeof LogSchema;
    };
    /**
     * @generated from rpc capabilities.blockchain.evm.v1alpha.Client.WriteReport
     */
    writeReport: {
        methodKind: 'unary';
        input: typeof WriteReportRequestSchema;
        output: typeof WriteReportReplySchema;
    };
}>;
