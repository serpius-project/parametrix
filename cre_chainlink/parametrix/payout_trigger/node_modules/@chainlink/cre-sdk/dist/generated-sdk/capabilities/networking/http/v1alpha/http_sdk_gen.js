import { create, fromJson } from '@bufbuild/protobuf';
import { AnySchema, anyPack } from '@bufbuild/protobuf/wkt';
import { ConfigSchema, PayloadSchema, } from '../../../../../generated/capabilities/networking/http/v1alpha/trigger_pb';
import {} from '../../../../../sdk';
import { Report } from '../../../../../sdk/report';
import { hexToBytes } from '../../../../../sdk/utils/hex-utils';
import {} from '../../../../../sdk/utils/triggers/trigger-interface';
/**
 * HTTP Capability
 *
 * Capability ID: http-trigger@1.0.0-alpha
 * Capability Name: http-trigger
 * Capability Version: 1.0.0-alpha
 */
export class HTTPCapability {
    /** The capability ID for this service */
    static CAPABILITY_ID = 'http-trigger@1.0.0-alpha';
    static CAPABILITY_NAME = 'http-trigger';
    static CAPABILITY_VERSION = '1.0.0-alpha';
    trigger(config) {
        const capabilityId = HTTPCapability.CAPABILITY_ID;
        return new HTTPTrigger(config, capabilityId, 'Trigger');
    }
}
/**
 * Trigger implementation for Trigger
 */
class HTTPTrigger {
    _capabilityId;
    _method;
    config;
    constructor(config, _capabilityId, _method) {
        this._capabilityId = _capabilityId;
        this._method = _method;
        // biome-ignore lint/suspicious/noExplicitAny: Needed for runtime type checking of protocol buffer messages
        this.config = config.$typeName
            ? config
            : fromJson(ConfigSchema, config);
    }
    capabilityId() {
        return this._capabilityId;
    }
    method() {
        return this._method;
    }
    outputSchema() {
        return PayloadSchema;
    }
    configAsAny() {
        return anyPack(ConfigSchema, this.config);
    }
    /**
     * Transform the raw trigger output - override this method if needed
     * Default implementation returns the raw output unchanged
     */
    adapt(rawOutput) {
        return rawOutput;
    }
}
