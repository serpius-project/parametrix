import { fromJson } from '@bufbuild/protobuf';
import { RequestSchema, ResponseSchema, } from '../../../../../generated/capabilities/networking/http/v1alpha/client_pb';
import {} from '../../../../../sdk';
import { Report } from '../../../../../sdk/report';
export class SendRequester {
    runtime;
    client;
    constructor(runtime, client) {
        this.runtime = runtime;
        this.client = client;
    }
    sendRequest(input) {
        return this.client.sendRequest(this.runtime, input);
    }
}
/**
 * Client Capability
 *
 * Capability ID: http-actions@1.0.0-alpha
 * Capability Name: http-actions
 * Capability Version: 1.0.0-alpha
 */
export class ClientCapability {
    /** The capability ID for this service */
    static CAPABILITY_ID = 'http-actions@1.0.0-alpha';
    static CAPABILITY_NAME = 'http-actions';
    static CAPABILITY_VERSION = '1.0.0-alpha';
    sendRequest(...args) {
        // Check if this is the sugar syntax overload (has function parameter)
        if (typeof args[1] === 'function') {
            const [runtime, fn, consensusAggregation, unwrapOptions] = args;
            return this.sendRequestSugarHelper(runtime, fn, consensusAggregation, unwrapOptions);
        }
        // Otherwise, this is the basic call overload
        const [runtime, input] = args;
        return this.sendRequestCallHelper(runtime, input);
    }
    sendRequestCallHelper(runtime, input) {
        // Handle input conversion - unwrap if it's a wrapped type, convert from JSON if needed
        let payload;
        if (input.$typeName) {
            // It's the original protobuf type
            payload = input;
        }
        else {
            // It's regular JSON, convert using fromJson
            payload = fromJson(RequestSchema, input);
        }
        const capabilityId = ClientCapability.CAPABILITY_ID;
        const capabilityResponse = runtime.callCapability({
            capabilityId,
            method: 'SendRequest',
            payload,
            inputSchema: RequestSchema,
            outputSchema: ResponseSchema,
        });
        return {
            result: () => {
                const result = capabilityResponse.result();
                return result;
            },
        };
    }
    sendRequestSugarHelper(runtime, fn, consensusAggregation, unwrapOptions) {
        const wrappedFn = (runtime, ...args) => {
            const sendRequester = new SendRequester(runtime, this);
            return fn(sendRequester, ...args);
        };
        return runtime.runInNodeMode(wrappedFn, consensusAggregation, unwrapOptions);
    }
}
