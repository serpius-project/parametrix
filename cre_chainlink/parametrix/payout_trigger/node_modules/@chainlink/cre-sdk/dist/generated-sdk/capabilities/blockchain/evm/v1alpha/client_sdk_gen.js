import { create, fromJson } from '@bufbuild/protobuf';
import { AnySchema, anyPack } from '@bufbuild/protobuf/wkt';
import { BalanceAtReplySchema, BalanceAtRequestSchema, CallContractReplySchema, CallContractRequestSchema, EstimateGasReplySchema, EstimateGasRequestSchema, FilterLogsReplySchema, FilterLogsRequestSchema, FilterLogTriggerRequestSchema, GasConfigSchema, GetTransactionByHashReplySchema, GetTransactionByHashRequestSchema, GetTransactionReceiptReplySchema, GetTransactionReceiptRequestSchema, HeaderByNumberReplySchema, HeaderByNumberRequestSchema, LogSchema, WriteReportReplySchema, WriteReportRequestSchema, } from '../../../../../generated/capabilities/blockchain/evm/v1alpha/client_pb';
import { ReportResponseSchema, } from '../../../../../generated/sdk/v1alpha/sdk_pb';
import {} from '../../../../../sdk';
import { Report } from '../../../../../sdk/report';
import { hexToBytes } from '../../../../../sdk/utils/hex-utils';
import {} from '../../../../../sdk/utils/triggers/trigger-interface';
export function x_generatedCodeOnly_wrap_WriteCreReportRequest(input) {
    return {
        receiver: input.receiver,
        report: input.report !== undefined ? new Report(input.report) : undefined,
        gasConfig: input.gasConfig,
        $report: true,
    };
}
export function createWriteCreReportRequest(input) {
    return {
        receiver: hexToBytes(input.receiver),
        report: input.report,
        gasConfig: input.gasConfig !== undefined ? fromJson(GasConfigSchema, input.gasConfig) : undefined,
        $report: true,
    };
}
export function x_generatedCodeOnly_unwrap_WriteCreReportRequest(input) {
    return create(WriteReportRequestSchema, {
        receiver: input.receiver,
        report: input.report !== undefined ? input.report.x_generatedCodeOnly_unwrap() : undefined,
        gasConfig: input.gasConfig,
    });
}
/**
 * Client Capability
 *
 * Capability ID: evm@1.0.0
 * Capability Name: evm
 * Capability Version: 1.0.0
 */
export class ClientCapability {
    ChainSelector;
    /** The capability ID for this service */
    static CAPABILITY_ID = 'evm@1.0.0';
    static CAPABILITY_NAME = 'evm';
    static CAPABILITY_VERSION = '1.0.0';
    /** Available ChainSelector values */
    static SUPPORTED_CHAIN_SELECTORS = {
        'apechain-testnet-curtis': 9900119385908781505n,
        'arc-testnet': 3034092155422581607n,
        'avalanche-mainnet': 6433500567565415381n,
        'avalanche-testnet-fuji': 14767482510784806043n,
        'binance_smart_chain-mainnet': 11344663589394136015n,
        'binance_smart_chain-testnet': 13264668187771770619n,
        'ethereum-mainnet': 5009297550715157269n,
        'ethereum-mainnet-arbitrum-1': 4949039107694359620n,
        'ethereum-mainnet-base-1': 15971525489660198786n,
        'ethereum-mainnet-optimism-1': 3734403246176062136n,
        'ethereum-mainnet-worldchain-1': 2049429975587534727n,
        'ethereum-mainnet-zksync-1': 1562403441176082196n,
        'ethereum-testnet-sepolia': 16015286601757825753n,
        'ethereum-testnet-sepolia-arbitrum-1': 3478487238524512106n,
        'ethereum-testnet-sepolia-base-1': 10344971235874465080n,
        'ethereum-testnet-sepolia-linea-1': 5719461335882077547n,
        'ethereum-testnet-sepolia-optimism-1': 5224473277236331295n,
        'ethereum-testnet-sepolia-worldchain-1': 5299555114858065850n,
        'ethereum-testnet-sepolia-zksync-1': 6898391096552792247n,
        'hyperliquid-testnet': 4286062357653186312n,
        'ink-testnet-sepolia': 9763904284804119144n,
        'jovay-testnet': 945045181441419236n,
        'plasma-testnet': 3967220077692964309n,
        'polygon-mainnet': 4051577828743386545n,
        'polygon-testnet-amoy': 16281711391670634445n,
        'private-testnet-andesite': 6915682381028791124n,
    };
    constructor(ChainSelector) {
        this.ChainSelector = ChainSelector;
    }
    callContract(runtime, input) {
        // Handle input conversion - unwrap if it's a wrapped type, convert from JSON if needed
        let payload;
        if (input.$typeName) {
            // It's the original protobuf type
            payload = input;
        }
        else {
            // It's regular JSON, convert using fromJson
            payload = fromJson(CallContractRequestSchema, input);
        }
        // Include all labels in capability ID for routing when specified
        const capabilityId = `${ClientCapability.CAPABILITY_NAME}:ChainSelector:${this.ChainSelector}@${ClientCapability.CAPABILITY_VERSION}`;
        const capabilityResponse = runtime.callCapability({
            capabilityId,
            method: 'CallContract',
            payload,
            inputSchema: CallContractRequestSchema,
            outputSchema: CallContractReplySchema,
        });
        return {
            result: () => {
                const result = capabilityResponse.result();
                return result;
            },
        };
    }
    filterLogs(runtime, input) {
        // Handle input conversion - unwrap if it's a wrapped type, convert from JSON if needed
        let payload;
        if (input.$typeName) {
            // It's the original protobuf type
            payload = input;
        }
        else {
            // It's regular JSON, convert using fromJson
            payload = fromJson(FilterLogsRequestSchema, input);
        }
        // Include all labels in capability ID for routing when specified
        const capabilityId = `${ClientCapability.CAPABILITY_NAME}:ChainSelector:${this.ChainSelector}@${ClientCapability.CAPABILITY_VERSION}`;
        const capabilityResponse = runtime.callCapability({
            capabilityId,
            method: 'FilterLogs',
            payload,
            inputSchema: FilterLogsRequestSchema,
            outputSchema: FilterLogsReplySchema,
        });
        return {
            result: () => {
                const result = capabilityResponse.result();
                return result;
            },
        };
    }
    balanceAt(runtime, input) {
        // Handle input conversion - unwrap if it's a wrapped type, convert from JSON if needed
        let payload;
        if (input.$typeName) {
            // It's the original protobuf type
            payload = input;
        }
        else {
            // It's regular JSON, convert using fromJson
            payload = fromJson(BalanceAtRequestSchema, input);
        }
        // Include all labels in capability ID for routing when specified
        const capabilityId = `${ClientCapability.CAPABILITY_NAME}:ChainSelector:${this.ChainSelector}@${ClientCapability.CAPABILITY_VERSION}`;
        const capabilityResponse = runtime.callCapability({
            capabilityId,
            method: 'BalanceAt',
            payload,
            inputSchema: BalanceAtRequestSchema,
            outputSchema: BalanceAtReplySchema,
        });
        return {
            result: () => {
                const result = capabilityResponse.result();
                return result;
            },
        };
    }
    estimateGas(runtime, input) {
        // Handle input conversion - unwrap if it's a wrapped type, convert from JSON if needed
        let payload;
        if (input.$typeName) {
            // It's the original protobuf type
            payload = input;
        }
        else {
            // It's regular JSON, convert using fromJson
            payload = fromJson(EstimateGasRequestSchema, input);
        }
        // Include all labels in capability ID for routing when specified
        const capabilityId = `${ClientCapability.CAPABILITY_NAME}:ChainSelector:${this.ChainSelector}@${ClientCapability.CAPABILITY_VERSION}`;
        const capabilityResponse = runtime.callCapability({
            capabilityId,
            method: 'EstimateGas',
            payload,
            inputSchema: EstimateGasRequestSchema,
            outputSchema: EstimateGasReplySchema,
        });
        return {
            result: () => {
                const result = capabilityResponse.result();
                return result;
            },
        };
    }
    getTransactionByHash(runtime, input) {
        // Handle input conversion - unwrap if it's a wrapped type, convert from JSON if needed
        let payload;
        if (input.$typeName) {
            // It's the original protobuf type
            payload = input;
        }
        else {
            // It's regular JSON, convert using fromJson
            payload = fromJson(GetTransactionByHashRequestSchema, input);
        }
        // Include all labels in capability ID for routing when specified
        const capabilityId = `${ClientCapability.CAPABILITY_NAME}:ChainSelector:${this.ChainSelector}@${ClientCapability.CAPABILITY_VERSION}`;
        const capabilityResponse = runtime.callCapability({
            capabilityId,
            method: 'GetTransactionByHash',
            payload,
            inputSchema: GetTransactionByHashRequestSchema,
            outputSchema: GetTransactionByHashReplySchema,
        });
        return {
            result: () => {
                const result = capabilityResponse.result();
                return result;
            },
        };
    }
    getTransactionReceipt(runtime, input) {
        // Handle input conversion - unwrap if it's a wrapped type, convert from JSON if needed
        let payload;
        if (input.$typeName) {
            // It's the original protobuf type
            payload = input;
        }
        else {
            // It's regular JSON, convert using fromJson
            payload = fromJson(GetTransactionReceiptRequestSchema, input);
        }
        // Include all labels in capability ID for routing when specified
        const capabilityId = `${ClientCapability.CAPABILITY_NAME}:ChainSelector:${this.ChainSelector}@${ClientCapability.CAPABILITY_VERSION}`;
        const capabilityResponse = runtime.callCapability({
            capabilityId,
            method: 'GetTransactionReceipt',
            payload,
            inputSchema: GetTransactionReceiptRequestSchema,
            outputSchema: GetTransactionReceiptReplySchema,
        });
        return {
            result: () => {
                const result = capabilityResponse.result();
                return result;
            },
        };
    }
    headerByNumber(runtime, input) {
        // Handle input conversion - unwrap if it's a wrapped type, convert from JSON if needed
        let payload;
        if (input.$typeName) {
            // It's the original protobuf type
            payload = input;
        }
        else {
            // It's regular JSON, convert using fromJson
            payload = fromJson(HeaderByNumberRequestSchema, input);
        }
        // Include all labels in capability ID for routing when specified
        const capabilityId = `${ClientCapability.CAPABILITY_NAME}:ChainSelector:${this.ChainSelector}@${ClientCapability.CAPABILITY_VERSION}`;
        const capabilityResponse = runtime.callCapability({
            capabilityId,
            method: 'HeaderByNumber',
            payload,
            inputSchema: HeaderByNumberRequestSchema,
            outputSchema: HeaderByNumberReplySchema,
        });
        return {
            result: () => {
                const result = capabilityResponse.result();
                return result;
            },
        };
    }
    logTrigger(config) {
        // Include all labels in capability ID for routing when specified
        const capabilityId = `${ClientCapability.CAPABILITY_NAME}:ChainSelector:${this.ChainSelector}@${ClientCapability.CAPABILITY_VERSION}`;
        return new ClientLogTrigger(config, capabilityId, 'LogTrigger', this.ChainSelector);
    }
    writeReport(runtime, input) {
        // Handle input conversion - unwrap if it's a wrapped type, convert from JSON if needed
        let payload;
        // Check if it's a wrapped type by looking for the $report property
        if (input.$report) {
            // It's a wrapped type, unwrap it
            payload = x_generatedCodeOnly_unwrap_WriteCreReportRequest(input);
        }
        else {
            // It's wrapped JSON, convert using create function
            payload = x_generatedCodeOnly_unwrap_WriteCreReportRequest(createWriteCreReportRequest(input));
        }
        // Include all labels in capability ID for routing when specified
        const capabilityId = `${ClientCapability.CAPABILITY_NAME}:ChainSelector:${this.ChainSelector}@${ClientCapability.CAPABILITY_VERSION}`;
        const capabilityResponse = runtime.callCapability({
            capabilityId,
            method: 'WriteReport',
            payload,
            inputSchema: WriteReportRequestSchema,
            outputSchema: WriteReportReplySchema,
        });
        return {
            result: () => {
                const result = capabilityResponse.result();
                return result;
            },
        };
    }
}
/**
 * Trigger implementation for LogTrigger
 */
class ClientLogTrigger {
    _capabilityId;
    _method;
    ChainSelector;
    config;
    constructor(config, _capabilityId, _method, ChainSelector) {
        this._capabilityId = _capabilityId;
        this._method = _method;
        this.ChainSelector = ChainSelector;
        // biome-ignore lint/suspicious/noExplicitAny: Needed for runtime type checking of protocol buffer messages
        this.config = config.$typeName
            ? config
            : fromJson(FilterLogTriggerRequestSchema, config);
    }
    capabilityId() {
        return this._capabilityId;
    }
    method() {
        return this._method;
    }
    outputSchema() {
        return LogSchema;
    }
    configAsAny() {
        return anyPack(FilterLogTriggerRequestSchema, this.config);
    }
    /**
     * Transform the raw trigger output - override this method if needed
     * Default implementation returns the raw output unchanged
     */
    adapt(rawOutput) {
        return rawOutput;
    }
}
